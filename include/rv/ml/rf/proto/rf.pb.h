// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rf.proto

#ifndef PROTOBUF_rf_2eproto__INCLUDED
#define PROTOBUF_rf_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace rv {
namespace rf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_rf_2eproto();
void protobuf_AssignDesc_rf_2eproto();
void protobuf_ShutdownFile_rf_2eproto();

class ForestParameter;
class SplitFunctionParameter;
class SplitEvaluatorParameter;
class LeafNodeFcnParameter;

enum ForestParameter_NodeType {
  ForestParameter_NodeType_SPLIT_NODE = 0,
  ForestParameter_NodeType_LEAF_NODE = 1
};
bool ForestParameter_NodeType_IsValid(int value);
const ForestParameter_NodeType ForestParameter_NodeType_NodeType_MIN = ForestParameter_NodeType_SPLIT_NODE;
const ForestParameter_NodeType ForestParameter_NodeType_NodeType_MAX = ForestParameter_NodeType_LEAF_NODE;
const int ForestParameter_NodeType_NodeType_ARRAYSIZE = ForestParameter_NodeType_NodeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ForestParameter_NodeType_descriptor();
inline const ::std::string& ForestParameter_NodeType_Name(ForestParameter_NodeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ForestParameter_NodeType_descriptor(), value);
}
inline bool ForestParameter_NodeType_Parse(
    const ::std::string& name, ForestParameter_NodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ForestParameter_NodeType>(
    ForestParameter_NodeType_descriptor(), name, value);
}
enum SplitFunctionParameter_SplitFunctionType {
  SplitFunctionParameter_SplitFunctionType_PIXEL_VALUE = 0,
  SplitFunctionParameter_SplitFunctionType_PIXEL_DIFFERENCE = 1,
  SplitFunctionParameter_SplitFunctionType_PIXEL_DIFFERENCE_DEPENDENT = 2,
  SplitFunctionParameter_SplitFunctionType_BASIS_FCN = 3
};
bool SplitFunctionParameter_SplitFunctionType_IsValid(int value);
const SplitFunctionParameter_SplitFunctionType SplitFunctionParameter_SplitFunctionType_SplitFunctionType_MIN = SplitFunctionParameter_SplitFunctionType_PIXEL_VALUE;
const SplitFunctionParameter_SplitFunctionType SplitFunctionParameter_SplitFunctionType_SplitFunctionType_MAX = SplitFunctionParameter_SplitFunctionType_BASIS_FCN;
const int SplitFunctionParameter_SplitFunctionType_SplitFunctionType_ARRAYSIZE = SplitFunctionParameter_SplitFunctionType_SplitFunctionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SplitFunctionParameter_SplitFunctionType_descriptor();
inline const ::std::string& SplitFunctionParameter_SplitFunctionType_Name(SplitFunctionParameter_SplitFunctionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SplitFunctionParameter_SplitFunctionType_descriptor(), value);
}
inline bool SplitFunctionParameter_SplitFunctionType_Parse(
    const ::std::string& name, SplitFunctionParameter_SplitFunctionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SplitFunctionParameter_SplitFunctionType>(
    SplitFunctionParameter_SplitFunctionType_descriptor(), name, value);
}
enum SplitFunctionParameter_GeneratorSpace {
  SplitFunctionParameter_GeneratorSpace_LINEAR = 0,
  SplitFunctionParameter_GeneratorSpace_LOG_10 = 1,
  SplitFunctionParameter_GeneratorSpace_DATA_LINEAR = 2
};
bool SplitFunctionParameter_GeneratorSpace_IsValid(int value);
const SplitFunctionParameter_GeneratorSpace SplitFunctionParameter_GeneratorSpace_GeneratorSpace_MIN = SplitFunctionParameter_GeneratorSpace_LINEAR;
const SplitFunctionParameter_GeneratorSpace SplitFunctionParameter_GeneratorSpace_GeneratorSpace_MAX = SplitFunctionParameter_GeneratorSpace_DATA_LINEAR;
const int SplitFunctionParameter_GeneratorSpace_GeneratorSpace_ARRAYSIZE = SplitFunctionParameter_GeneratorSpace_GeneratorSpace_MAX + 1;

const ::google::protobuf::EnumDescriptor* SplitFunctionParameter_GeneratorSpace_descriptor();
inline const ::std::string& SplitFunctionParameter_GeneratorSpace_Name(SplitFunctionParameter_GeneratorSpace value) {
  return ::google::protobuf::internal::NameOfEnum(
    SplitFunctionParameter_GeneratorSpace_descriptor(), value);
}
inline bool SplitFunctionParameter_GeneratorSpace_Parse(
    const ::std::string& name, SplitFunctionParameter_GeneratorSpace* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SplitFunctionParameter_GeneratorSpace>(
    SplitFunctionParameter_GeneratorSpace_descriptor(), name, value);
}
enum SplitEvaluatorParameter_SplitEvaluatorType {
  SplitEvaluatorParameter_SplitEvaluatorType_CLASSIFICATION_INFORMATION_GAIN = 0,
  SplitEvaluatorParameter_SplitEvaluatorType_CLASSIFICATION_GINI = 1,
  SplitEvaluatorParameter_SplitEvaluatorType_REGRESSION_TRACE_COV = 2,
  SplitEvaluatorParameter_SplitEvaluatorType_REGRESSION_VARIANCE_REDUCTION = 3,
  SplitEvaluatorParameter_SplitEvaluatorType_REGRESSION_WEIGHTED_TRACE_COV = 4
};
bool SplitEvaluatorParameter_SplitEvaluatorType_IsValid(int value);
const SplitEvaluatorParameter_SplitEvaluatorType SplitEvaluatorParameter_SplitEvaluatorType_SplitEvaluatorType_MIN = SplitEvaluatorParameter_SplitEvaluatorType_CLASSIFICATION_INFORMATION_GAIN;
const SplitEvaluatorParameter_SplitEvaluatorType SplitEvaluatorParameter_SplitEvaluatorType_SplitEvaluatorType_MAX = SplitEvaluatorParameter_SplitEvaluatorType_REGRESSION_WEIGHTED_TRACE_COV;
const int SplitEvaluatorParameter_SplitEvaluatorType_SplitEvaluatorType_ARRAYSIZE = SplitEvaluatorParameter_SplitEvaluatorType_SplitEvaluatorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SplitEvaluatorParameter_SplitEvaluatorType_descriptor();
inline const ::std::string& SplitEvaluatorParameter_SplitEvaluatorType_Name(SplitEvaluatorParameter_SplitEvaluatorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SplitEvaluatorParameter_SplitEvaluatorType_descriptor(), value);
}
inline bool SplitEvaluatorParameter_SplitEvaluatorType_Parse(
    const ::std::string& name, SplitEvaluatorParameter_SplitEvaluatorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SplitEvaluatorParameter_SplitEvaluatorType>(
    SplitEvaluatorParameter_SplitEvaluatorType_descriptor(), name, value);
}
enum LeafNodeFcnParameter_LeafNodeFcnType {
  LeafNodeFcnParameter_LeafNodeFcnType_CLASSIFICATION = 0,
  LeafNodeFcnParameter_LeafNodeFcnType_REGRESSION_MEAN = 1,
  LeafNodeFcnParameter_LeafNodeFcnType_REGRESSION_MEAN_STD = 2,
  LeafNodeFcnParameter_LeafNodeFcnType_REGRESSION_MEDIAN = 3,
  LeafNodeFcnParameter_LeafNodeFcnType_REGRESSION_REGRESSION = 4
};
bool LeafNodeFcnParameter_LeafNodeFcnType_IsValid(int value);
const LeafNodeFcnParameter_LeafNodeFcnType LeafNodeFcnParameter_LeafNodeFcnType_LeafNodeFcnType_MIN = LeafNodeFcnParameter_LeafNodeFcnType_CLASSIFICATION;
const LeafNodeFcnParameter_LeafNodeFcnType LeafNodeFcnParameter_LeafNodeFcnType_LeafNodeFcnType_MAX = LeafNodeFcnParameter_LeafNodeFcnType_REGRESSION_REGRESSION;
const int LeafNodeFcnParameter_LeafNodeFcnType_LeafNodeFcnType_ARRAYSIZE = LeafNodeFcnParameter_LeafNodeFcnType_LeafNodeFcnType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LeafNodeFcnParameter_LeafNodeFcnType_descriptor();
inline const ::std::string& LeafNodeFcnParameter_LeafNodeFcnType_Name(LeafNodeFcnParameter_LeafNodeFcnType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LeafNodeFcnParameter_LeafNodeFcnType_descriptor(), value);
}
inline bool LeafNodeFcnParameter_LeafNodeFcnType_Parse(
    const ::std::string& name, LeafNodeFcnParameter_LeafNodeFcnType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LeafNodeFcnParameter_LeafNodeFcnType>(
    LeafNodeFcnParameter_LeafNodeFcnType_descriptor(), name, value);
}
// ===================================================================

class ForestParameter : public ::google::protobuf::Message {
 public:
  ForestParameter();
  virtual ~ForestParameter();

  ForestParameter(const ForestParameter& from);

  inline ForestParameter& operator=(const ForestParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ForestParameter& default_instance();

  void Swap(ForestParameter* other);

  // implements Message ----------------------------------------------

  ForestParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ForestParameter& from);
  void MergeFrom(const ForestParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ForestParameter_NodeType NodeType;
  static const NodeType SPLIT_NODE = ForestParameter_NodeType_SPLIT_NODE;
  static const NodeType LEAF_NODE = ForestParameter_NodeType_LEAF_NODE;
  static inline bool NodeType_IsValid(int value) {
    return ForestParameter_NodeType_IsValid(value);
  }
  static const NodeType NodeType_MIN =
    ForestParameter_NodeType_NodeType_MIN;
  static const NodeType NodeType_MAX =
    ForestParameter_NodeType_NodeType_MAX;
  static const int NodeType_ARRAYSIZE =
    ForestParameter_NodeType_NodeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NodeType_descriptor() {
    return ForestParameter_NodeType_descriptor();
  }
  static inline const ::std::string& NodeType_Name(NodeType value) {
    return ForestParameter_NodeType_Name(value);
  }
  static inline bool NodeType_Parse(const ::std::string& name,
      NodeType* value) {
    return ForestParameter_NodeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .rv.rf.SplitFunctionParameter split_function_param = 1;
  inline bool has_split_function_param() const;
  inline void clear_split_function_param();
  static const int kSplitFunctionParamFieldNumber = 1;
  inline const ::rv::rf::SplitFunctionParameter& split_function_param() const;
  inline ::rv::rf::SplitFunctionParameter* mutable_split_function_param();
  inline ::rv::rf::SplitFunctionParameter* release_split_function_param();
  inline void set_allocated_split_function_param(::rv::rf::SplitFunctionParameter* split_function_param);

  // repeated .rv.rf.SplitEvaluatorParameter split_evaluator_param = 2;
  inline int split_evaluator_param_size() const;
  inline void clear_split_evaluator_param();
  static const int kSplitEvaluatorParamFieldNumber = 2;
  inline const ::rv::rf::SplitEvaluatorParameter& split_evaluator_param(int index) const;
  inline ::rv::rf::SplitEvaluatorParameter* mutable_split_evaluator_param(int index);
  inline ::rv::rf::SplitEvaluatorParameter* add_split_evaluator_param();
  inline const ::google::protobuf::RepeatedPtrField< ::rv::rf::SplitEvaluatorParameter >&
      split_evaluator_param() const;
  inline ::google::protobuf::RepeatedPtrField< ::rv::rf::SplitEvaluatorParameter >*
      mutable_split_evaluator_param();

  // repeated .rv.rf.LeafNodeFcnParameter leaf_node_fcn_param = 3;
  inline int leaf_node_fcn_param_size() const;
  inline void clear_leaf_node_fcn_param();
  static const int kLeafNodeFcnParamFieldNumber = 3;
  inline const ::rv::rf::LeafNodeFcnParameter& leaf_node_fcn_param(int index) const;
  inline ::rv::rf::LeafNodeFcnParameter* mutable_leaf_node_fcn_param(int index);
  inline ::rv::rf::LeafNodeFcnParameter* add_leaf_node_fcn_param();
  inline const ::google::protobuf::RepeatedPtrField< ::rv::rf::LeafNodeFcnParameter >&
      leaf_node_fcn_param() const;
  inline ::google::protobuf::RepeatedPtrField< ::rv::rf::LeafNodeFcnParameter >*
      mutable_leaf_node_fcn_param();

  // optional uint32 n_trees = 5 [default = 4];
  inline bool has_n_trees() const;
  inline void clear_n_trees();
  static const int kNTreesFieldNumber = 5;
  inline ::google::protobuf::uint32 n_trees() const;
  inline void set_n_trees(::google::protobuf::uint32 value);

  // optional uint32 max_tree_depth = 6 [default = 5];
  inline bool has_max_tree_depth() const;
  inline void clear_max_tree_depth();
  static const int kMaxTreeDepthFieldNumber = 6;
  inline ::google::protobuf::uint32 max_tree_depth() const;
  inline void set_max_tree_depth(::google::protobuf::uint32 value);

  // optional uint32 n_test_samples = 7 [default = 1000];
  inline bool has_n_test_samples() const;
  inline void clear_n_test_samples();
  static const int kNTestSamplesFieldNumber = 7;
  inline ::google::protobuf::uint32 n_test_samples() const;
  inline void set_n_test_samples(::google::protobuf::uint32 value);

  // optional uint32 n_test_split_functions = 8 [default = 100];
  inline bool has_n_test_split_functions() const;
  inline void clear_n_test_split_functions();
  static const int kNTestSplitFunctionsFieldNumber = 8;
  inline ::google::protobuf::uint32 n_test_split_functions() const;
  inline void set_n_test_split_functions(::google::protobuf::uint32 value);

  // optional uint32 n_test_thresholds = 9 [default = 10];
  inline bool has_n_test_thresholds() const;
  inline void clear_n_test_thresholds();
  static const int kNTestThresholdsFieldNumber = 9;
  inline ::google::protobuf::uint32 n_test_thresholds() const;
  inline void set_n_test_thresholds(::google::protobuf::uint32 value);

  // optional uint32 min_samples_to_split = 10 [default = 5];
  inline bool has_min_samples_to_split() const;
  inline void clear_min_samples_to_split();
  static const int kMinSamplesToSplitFieldNumber = 10;
  inline ::google::protobuf::uint32 min_samples_to_split() const;
  inline void set_min_samples_to_split(::google::protobuf::uint32 value);

  // optional uint32 min_samples_for_leaf = 11 [default = 1];
  inline bool has_min_samples_for_leaf() const;
  inline void clear_min_samples_for_leaf();
  static const int kMinSamplesForLeafFieldNumber = 11;
  inline ::google::protobuf::uint32 min_samples_for_leaf() const;
  inline void set_min_samples_for_leaf(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:rv.rf.ForestParameter)
 private:
  inline void set_has_split_function_param();
  inline void clear_has_split_function_param();
  inline void set_has_n_trees();
  inline void clear_has_n_trees();
  inline void set_has_max_tree_depth();
  inline void clear_has_max_tree_depth();
  inline void set_has_n_test_samples();
  inline void clear_has_n_test_samples();
  inline void set_has_n_test_split_functions();
  inline void clear_has_n_test_split_functions();
  inline void set_has_n_test_thresholds();
  inline void clear_has_n_test_thresholds();
  inline void set_has_min_samples_to_split();
  inline void clear_has_min_samples_to_split();
  inline void set_has_min_samples_for_leaf();
  inline void clear_has_min_samples_for_leaf();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::rv::rf::SplitFunctionParameter* split_function_param_;
  ::google::protobuf::RepeatedPtrField< ::rv::rf::SplitEvaluatorParameter > split_evaluator_param_;
  ::google::protobuf::RepeatedPtrField< ::rv::rf::LeafNodeFcnParameter > leaf_node_fcn_param_;
  ::google::protobuf::uint32 n_trees_;
  ::google::protobuf::uint32 max_tree_depth_;
  ::google::protobuf::uint32 n_test_samples_;
  ::google::protobuf::uint32 n_test_split_functions_;
  ::google::protobuf::uint32 n_test_thresholds_;
  ::google::protobuf::uint32 min_samples_to_split_;
  ::google::protobuf::uint32 min_samples_for_leaf_;
  friend void  protobuf_AddDesc_rf_2eproto();
  friend void protobuf_AssignDesc_rf_2eproto();
  friend void protobuf_ShutdownFile_rf_2eproto();

  void InitAsDefaultInstance();
  static ForestParameter* default_instance_;
};
// -------------------------------------------------------------------

class SplitFunctionParameter : public ::google::protobuf::Message {
 public:
  SplitFunctionParameter();
  virtual ~SplitFunctionParameter();

  SplitFunctionParameter(const SplitFunctionParameter& from);

  inline SplitFunctionParameter& operator=(const SplitFunctionParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SplitFunctionParameter& default_instance();

  void Swap(SplitFunctionParameter* other);

  // implements Message ----------------------------------------------

  SplitFunctionParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SplitFunctionParameter& from);
  void MergeFrom(const SplitFunctionParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SplitFunctionParameter_SplitFunctionType SplitFunctionType;
  static const SplitFunctionType PIXEL_VALUE = SplitFunctionParameter_SplitFunctionType_PIXEL_VALUE;
  static const SplitFunctionType PIXEL_DIFFERENCE = SplitFunctionParameter_SplitFunctionType_PIXEL_DIFFERENCE;
  static const SplitFunctionType PIXEL_DIFFERENCE_DEPENDENT = SplitFunctionParameter_SplitFunctionType_PIXEL_DIFFERENCE_DEPENDENT;
  static const SplitFunctionType BASIS_FCN = SplitFunctionParameter_SplitFunctionType_BASIS_FCN;
  static inline bool SplitFunctionType_IsValid(int value) {
    return SplitFunctionParameter_SplitFunctionType_IsValid(value);
  }
  static const SplitFunctionType SplitFunctionType_MIN =
    SplitFunctionParameter_SplitFunctionType_SplitFunctionType_MIN;
  static const SplitFunctionType SplitFunctionType_MAX =
    SplitFunctionParameter_SplitFunctionType_SplitFunctionType_MAX;
  static const int SplitFunctionType_ARRAYSIZE =
    SplitFunctionParameter_SplitFunctionType_SplitFunctionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SplitFunctionType_descriptor() {
    return SplitFunctionParameter_SplitFunctionType_descriptor();
  }
  static inline const ::std::string& SplitFunctionType_Name(SplitFunctionType value) {
    return SplitFunctionParameter_SplitFunctionType_Name(value);
  }
  static inline bool SplitFunctionType_Parse(const ::std::string& name,
      SplitFunctionType* value) {
    return SplitFunctionParameter_SplitFunctionType_Parse(name, value);
  }

  typedef SplitFunctionParameter_GeneratorSpace GeneratorSpace;
  static const GeneratorSpace LINEAR = SplitFunctionParameter_GeneratorSpace_LINEAR;
  static const GeneratorSpace LOG_10 = SplitFunctionParameter_GeneratorSpace_LOG_10;
  static const GeneratorSpace DATA_LINEAR = SplitFunctionParameter_GeneratorSpace_DATA_LINEAR;
  static inline bool GeneratorSpace_IsValid(int value) {
    return SplitFunctionParameter_GeneratorSpace_IsValid(value);
  }
  static const GeneratorSpace GeneratorSpace_MIN =
    SplitFunctionParameter_GeneratorSpace_GeneratorSpace_MIN;
  static const GeneratorSpace GeneratorSpace_MAX =
    SplitFunctionParameter_GeneratorSpace_GeneratorSpace_MAX;
  static const int GeneratorSpace_ARRAYSIZE =
    SplitFunctionParameter_GeneratorSpace_GeneratorSpace_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GeneratorSpace_descriptor() {
    return SplitFunctionParameter_GeneratorSpace_descriptor();
  }
  static inline const ::std::string& GeneratorSpace_Name(GeneratorSpace value) {
    return SplitFunctionParameter_GeneratorSpace_Name(value);
  }
  static inline bool GeneratorSpace_Parse(const ::std::string& name,
      GeneratorSpace* value) {
    return SplitFunctionParameter_GeneratorSpace_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .rv.rf.SplitFunctionParameter.SplitFunctionType type = 1 [default = PIXEL_VALUE];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::rv::rf::SplitFunctionParameter_SplitFunctionType type() const;
  inline void set_type(::rv::rf::SplitFunctionParameter_SplitFunctionType value);

  // optional uint32 gen_n_slices = 2 [default = 1];
  inline bool has_gen_n_slices() const;
  inline void clear_gen_n_slices();
  static const int kGenNSlicesFieldNumber = 2;
  inline ::google::protobuf::uint32 gen_n_slices() const;
  inline void set_gen_n_slices(::google::protobuf::uint32 value);

  // optional bool gen_fix_one = 3 [default = false];
  inline bool has_gen_fix_one() const;
  inline void clear_gen_fix_one();
  static const int kGenFixOneFieldNumber = 3;
  inline bool gen_fix_one() const;
  inline void set_gen_fix_one(bool value);

  // optional .rv.rf.SplitFunctionParameter.GeneratorSpace gen_space = 4 [default = DATA_LINEAR];
  inline bool has_gen_space() const;
  inline void clear_gen_space();
  static const int kGenSpaceFieldNumber = 4;
  inline ::rv::rf::SplitFunctionParameter_GeneratorSpace gen_space() const;
  inline void set_gen_space(::rv::rf::SplitFunctionParameter_GeneratorSpace value);

  // optional float gen_x_from = 5;
  inline bool has_gen_x_from() const;
  inline void clear_gen_x_from();
  static const int kGenXFromFieldNumber = 5;
  inline float gen_x_from() const;
  inline void set_gen_x_from(float value);

  // optional float gen_x_to = 6;
  inline bool has_gen_x_to() const;
  inline void clear_gen_x_to();
  static const int kGenXToFieldNumber = 6;
  inline float gen_x_to() const;
  inline void set_gen_x_to(float value);

  // optional uint32 gen_x_n = 7;
  inline bool has_gen_x_n() const;
  inline void clear_gen_x_n();
  static const int kGenXNFieldNumber = 7;
  inline ::google::protobuf::uint32 gen_x_n() const;
  inline void set_gen_x_n(::google::protobuf::uint32 value);

  // optional float gen_y_from = 8;
  inline bool has_gen_y_from() const;
  inline void clear_gen_y_from();
  static const int kGenYFromFieldNumber = 8;
  inline float gen_y_from() const;
  inline void set_gen_y_from(float value);

  // optional float gen_y_to = 9;
  inline bool has_gen_y_to() const;
  inline void clear_gen_y_to();
  static const int kGenYToFieldNumber = 9;
  inline float gen_y_to() const;
  inline void set_gen_y_to(float value);

  // optional uint32 gen_y_n = 10;
  inline bool has_gen_y_n() const;
  inline void clear_gen_y_n();
  static const int kGenYNFieldNumber = 10;
  inline ::google::protobuf::uint32 gen_y_n() const;
  inline void set_gen_y_n(::google::protobuf::uint32 value);

  // optional string basis_csv = 11 [default = ""];
  inline bool has_basis_csv() const;
  inline void clear_basis_csv();
  static const int kBasisCsvFieldNumber = 11;
  inline const ::std::string& basis_csv() const;
  inline void set_basis_csv(const ::std::string& value);
  inline void set_basis_csv(const char* value);
  inline void set_basis_csv(const char* value, size_t size);
  inline ::std::string* mutable_basis_csv();
  inline ::std::string* release_basis_csv();
  inline void set_allocated_basis_csv(::std::string* basis_csv);

  // @@protoc_insertion_point(class_scope:rv.rf.SplitFunctionParameter)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_gen_n_slices();
  inline void clear_has_gen_n_slices();
  inline void set_has_gen_fix_one();
  inline void clear_has_gen_fix_one();
  inline void set_has_gen_space();
  inline void clear_has_gen_space();
  inline void set_has_gen_x_from();
  inline void clear_has_gen_x_from();
  inline void set_has_gen_x_to();
  inline void clear_has_gen_x_to();
  inline void set_has_gen_x_n();
  inline void clear_has_gen_x_n();
  inline void set_has_gen_y_from();
  inline void clear_has_gen_y_from();
  inline void set_has_gen_y_to();
  inline void clear_has_gen_y_to();
  inline void set_has_gen_y_n();
  inline void clear_has_gen_y_n();
  inline void set_has_basis_csv();
  inline void clear_has_basis_csv();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  ::google::protobuf::uint32 gen_n_slices_;
  bool gen_fix_one_;
  int gen_space_;
  float gen_x_from_;
  float gen_x_to_;
  ::google::protobuf::uint32 gen_x_n_;
  float gen_y_from_;
  float gen_y_to_;
  ::google::protobuf::uint32 gen_y_n_;
  ::std::string* basis_csv_;
  friend void  protobuf_AddDesc_rf_2eproto();
  friend void protobuf_AssignDesc_rf_2eproto();
  friend void protobuf_ShutdownFile_rf_2eproto();

  void InitAsDefaultInstance();
  static SplitFunctionParameter* default_instance_;
};
// -------------------------------------------------------------------

class SplitEvaluatorParameter : public ::google::protobuf::Message {
 public:
  SplitEvaluatorParameter();
  virtual ~SplitEvaluatorParameter();

  SplitEvaluatorParameter(const SplitEvaluatorParameter& from);

  inline SplitEvaluatorParameter& operator=(const SplitEvaluatorParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SplitEvaluatorParameter& default_instance();

  void Swap(SplitEvaluatorParameter* other);

  // implements Message ----------------------------------------------

  SplitEvaluatorParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SplitEvaluatorParameter& from);
  void MergeFrom(const SplitEvaluatorParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SplitEvaluatorParameter_SplitEvaluatorType SplitEvaluatorType;
  static const SplitEvaluatorType CLASSIFICATION_INFORMATION_GAIN = SplitEvaluatorParameter_SplitEvaluatorType_CLASSIFICATION_INFORMATION_GAIN;
  static const SplitEvaluatorType CLASSIFICATION_GINI = SplitEvaluatorParameter_SplitEvaluatorType_CLASSIFICATION_GINI;
  static const SplitEvaluatorType REGRESSION_TRACE_COV = SplitEvaluatorParameter_SplitEvaluatorType_REGRESSION_TRACE_COV;
  static const SplitEvaluatorType REGRESSION_VARIANCE_REDUCTION = SplitEvaluatorParameter_SplitEvaluatorType_REGRESSION_VARIANCE_REDUCTION;
  static const SplitEvaluatorType REGRESSION_WEIGHTED_TRACE_COV = SplitEvaluatorParameter_SplitEvaluatorType_REGRESSION_WEIGHTED_TRACE_COV;
  static inline bool SplitEvaluatorType_IsValid(int value) {
    return SplitEvaluatorParameter_SplitEvaluatorType_IsValid(value);
  }
  static const SplitEvaluatorType SplitEvaluatorType_MIN =
    SplitEvaluatorParameter_SplitEvaluatorType_SplitEvaluatorType_MIN;
  static const SplitEvaluatorType SplitEvaluatorType_MAX =
    SplitEvaluatorParameter_SplitEvaluatorType_SplitEvaluatorType_MAX;
  static const int SplitEvaluatorType_ARRAYSIZE =
    SplitEvaluatorParameter_SplitEvaluatorType_SplitEvaluatorType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SplitEvaluatorType_descriptor() {
    return SplitEvaluatorParameter_SplitEvaluatorType_descriptor();
  }
  static inline const ::std::string& SplitEvaluatorType_Name(SplitEvaluatorType value) {
    return SplitEvaluatorParameter_SplitEvaluatorType_Name(value);
  }
  static inline bool SplitEvaluatorType_Parse(const ::std::string& name,
      SplitEvaluatorType* value) {
    return SplitEvaluatorParameter_SplitEvaluatorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .rv.rf.SplitEvaluatorParameter.SplitEvaluatorType type = 1 [default = CLASSIFICATION_INFORMATION_GAIN];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::rv::rf::SplitEvaluatorParameter_SplitEvaluatorType type() const;
  inline void set_type(::rv::rf::SplitEvaluatorParameter_SplitEvaluatorType value);

  // optional bool normalize = 2 [default = true];
  inline bool has_normalize() const;
  inline void clear_normalize();
  static const int kNormalizeFieldNumber = 2;
  inline bool normalize() const;
  inline void set_normalize(bool value);

  // optional float weight = 3 [default = 1];
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 3;
  inline float weight() const;
  inline void set_weight(float value);

  // optional bool weighted_mean = 4 [default = false];
  inline bool has_weighted_mean() const;
  inline void clear_weighted_mean();
  static const int kWeightedMeanFieldNumber = 4;
  inline bool weighted_mean() const;
  inline void set_weighted_mean(bool value);

  // @@protoc_insertion_point(class_scope:rv.rf.SplitEvaluatorParameter)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_normalize();
  inline void clear_has_normalize();
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_weighted_mean();
  inline void clear_has_weighted_mean();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  float weight_;
  bool normalize_;
  bool weighted_mean_;
  friend void  protobuf_AddDesc_rf_2eproto();
  friend void protobuf_AssignDesc_rf_2eproto();
  friend void protobuf_ShutdownFile_rf_2eproto();

  void InitAsDefaultInstance();
  static SplitEvaluatorParameter* default_instance_;
};
// -------------------------------------------------------------------

class LeafNodeFcnParameter : public ::google::protobuf::Message {
 public:
  LeafNodeFcnParameter();
  virtual ~LeafNodeFcnParameter();

  LeafNodeFcnParameter(const LeafNodeFcnParameter& from);

  inline LeafNodeFcnParameter& operator=(const LeafNodeFcnParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeafNodeFcnParameter& default_instance();

  void Swap(LeafNodeFcnParameter* other);

  // implements Message ----------------------------------------------

  LeafNodeFcnParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeafNodeFcnParameter& from);
  void MergeFrom(const LeafNodeFcnParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LeafNodeFcnParameter_LeafNodeFcnType LeafNodeFcnType;
  static const LeafNodeFcnType CLASSIFICATION = LeafNodeFcnParameter_LeafNodeFcnType_CLASSIFICATION;
  static const LeafNodeFcnType REGRESSION_MEAN = LeafNodeFcnParameter_LeafNodeFcnType_REGRESSION_MEAN;
  static const LeafNodeFcnType REGRESSION_MEAN_STD = LeafNodeFcnParameter_LeafNodeFcnType_REGRESSION_MEAN_STD;
  static const LeafNodeFcnType REGRESSION_MEDIAN = LeafNodeFcnParameter_LeafNodeFcnType_REGRESSION_MEDIAN;
  static const LeafNodeFcnType REGRESSION_REGRESSION = LeafNodeFcnParameter_LeafNodeFcnType_REGRESSION_REGRESSION;
  static inline bool LeafNodeFcnType_IsValid(int value) {
    return LeafNodeFcnParameter_LeafNodeFcnType_IsValid(value);
  }
  static const LeafNodeFcnType LeafNodeFcnType_MIN =
    LeafNodeFcnParameter_LeafNodeFcnType_LeafNodeFcnType_MIN;
  static const LeafNodeFcnType LeafNodeFcnType_MAX =
    LeafNodeFcnParameter_LeafNodeFcnType_LeafNodeFcnType_MAX;
  static const int LeafNodeFcnType_ARRAYSIZE =
    LeafNodeFcnParameter_LeafNodeFcnType_LeafNodeFcnType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LeafNodeFcnType_descriptor() {
    return LeafNodeFcnParameter_LeafNodeFcnType_descriptor();
  }
  static inline const ::std::string& LeafNodeFcnType_Name(LeafNodeFcnType value) {
    return LeafNodeFcnParameter_LeafNodeFcnType_Name(value);
  }
  static inline bool LeafNodeFcnType_Parse(const ::std::string& name,
      LeafNodeFcnType* value) {
    return LeafNodeFcnParameter_LeafNodeFcnType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .rv.rf.LeafNodeFcnParameter.LeafNodeFcnType type = 1 [default = CLASSIFICATION];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::rv::rf::LeafNodeFcnParameter_LeafNodeFcnType type() const;
  inline void set_type(::rv::rf::LeafNodeFcnParameter_LeafNodeFcnType value);

  // optional float lambda = 2 [default = 0];
  inline bool has_lambda() const;
  inline void clear_lambda();
  static const int kLambdaFieldNumber = 2;
  inline float lambda() const;
  inline void set_lambda(float value);

  // optional bool use_bias = 3 [default = true];
  inline bool has_use_bias() const;
  inline void clear_use_bias();
  static const int kUseBiasFieldNumber = 3;
  inline bool use_bias() const;
  inline void set_use_bias(bool value);

  // optional uint32 poly_degree = 4 [default = 1];
  inline bool has_poly_degree() const;
  inline void clear_poly_degree();
  static const int kPolyDegreeFieldNumber = 4;
  inline ::google::protobuf::uint32 poly_degree() const;
  inline void set_poly_degree(::google::protobuf::uint32 value);

  // optional bool weighted_regression = 5 [default = false];
  inline bool has_weighted_regression() const;
  inline void clear_weighted_regression();
  static const int kWeightedRegressionFieldNumber = 5;
  inline bool weighted_regression() const;
  inline void set_weighted_regression(bool value);

  // @@protoc_insertion_point(class_scope:rv.rf.LeafNodeFcnParameter)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_lambda();
  inline void clear_has_lambda();
  inline void set_has_use_bias();
  inline void clear_has_use_bias();
  inline void set_has_poly_degree();
  inline void clear_has_poly_degree();
  inline void set_has_weighted_regression();
  inline void clear_has_weighted_regression();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  float lambda_;
  ::google::protobuf::uint32 poly_degree_;
  bool use_bias_;
  bool weighted_regression_;
  friend void  protobuf_AddDesc_rf_2eproto();
  friend void protobuf_AssignDesc_rf_2eproto();
  friend void protobuf_ShutdownFile_rf_2eproto();

  void InitAsDefaultInstance();
  static LeafNodeFcnParameter* default_instance_;
};
// ===================================================================


// ===================================================================

// ForestParameter

// optional .rv.rf.SplitFunctionParameter split_function_param = 1;
inline bool ForestParameter::has_split_function_param() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ForestParameter::set_has_split_function_param() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ForestParameter::clear_has_split_function_param() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ForestParameter::clear_split_function_param() {
  if (split_function_param_ != NULL) split_function_param_->::rv::rf::SplitFunctionParameter::Clear();
  clear_has_split_function_param();
}
inline const ::rv::rf::SplitFunctionParameter& ForestParameter::split_function_param() const {
  // @@protoc_insertion_point(field_get:rv.rf.ForestParameter.split_function_param)
  return split_function_param_ != NULL ? *split_function_param_ : *default_instance_->split_function_param_;
}
inline ::rv::rf::SplitFunctionParameter* ForestParameter::mutable_split_function_param() {
  set_has_split_function_param();
  if (split_function_param_ == NULL) split_function_param_ = new ::rv::rf::SplitFunctionParameter;
  // @@protoc_insertion_point(field_mutable:rv.rf.ForestParameter.split_function_param)
  return split_function_param_;
}
inline ::rv::rf::SplitFunctionParameter* ForestParameter::release_split_function_param() {
  clear_has_split_function_param();
  ::rv::rf::SplitFunctionParameter* temp = split_function_param_;
  split_function_param_ = NULL;
  return temp;
}
inline void ForestParameter::set_allocated_split_function_param(::rv::rf::SplitFunctionParameter* split_function_param) {
  delete split_function_param_;
  split_function_param_ = split_function_param;
  if (split_function_param) {
    set_has_split_function_param();
  } else {
    clear_has_split_function_param();
  }
  // @@protoc_insertion_point(field_set_allocated:rv.rf.ForestParameter.split_function_param)
}

// repeated .rv.rf.SplitEvaluatorParameter split_evaluator_param = 2;
inline int ForestParameter::split_evaluator_param_size() const {
  return split_evaluator_param_.size();
}
inline void ForestParameter::clear_split_evaluator_param() {
  split_evaluator_param_.Clear();
}
inline const ::rv::rf::SplitEvaluatorParameter& ForestParameter::split_evaluator_param(int index) const {
  // @@protoc_insertion_point(field_get:rv.rf.ForestParameter.split_evaluator_param)
  return split_evaluator_param_.Get(index);
}
inline ::rv::rf::SplitEvaluatorParameter* ForestParameter::mutable_split_evaluator_param(int index) {
  // @@protoc_insertion_point(field_mutable:rv.rf.ForestParameter.split_evaluator_param)
  return split_evaluator_param_.Mutable(index);
}
inline ::rv::rf::SplitEvaluatorParameter* ForestParameter::add_split_evaluator_param() {
  // @@protoc_insertion_point(field_add:rv.rf.ForestParameter.split_evaluator_param)
  return split_evaluator_param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rv::rf::SplitEvaluatorParameter >&
ForestParameter::split_evaluator_param() const {
  // @@protoc_insertion_point(field_list:rv.rf.ForestParameter.split_evaluator_param)
  return split_evaluator_param_;
}
inline ::google::protobuf::RepeatedPtrField< ::rv::rf::SplitEvaluatorParameter >*
ForestParameter::mutable_split_evaluator_param() {
  // @@protoc_insertion_point(field_mutable_list:rv.rf.ForestParameter.split_evaluator_param)
  return &split_evaluator_param_;
}

// repeated .rv.rf.LeafNodeFcnParameter leaf_node_fcn_param = 3;
inline int ForestParameter::leaf_node_fcn_param_size() const {
  return leaf_node_fcn_param_.size();
}
inline void ForestParameter::clear_leaf_node_fcn_param() {
  leaf_node_fcn_param_.Clear();
}
inline const ::rv::rf::LeafNodeFcnParameter& ForestParameter::leaf_node_fcn_param(int index) const {
  // @@protoc_insertion_point(field_get:rv.rf.ForestParameter.leaf_node_fcn_param)
  return leaf_node_fcn_param_.Get(index);
}
inline ::rv::rf::LeafNodeFcnParameter* ForestParameter::mutable_leaf_node_fcn_param(int index) {
  // @@protoc_insertion_point(field_mutable:rv.rf.ForestParameter.leaf_node_fcn_param)
  return leaf_node_fcn_param_.Mutable(index);
}
inline ::rv::rf::LeafNodeFcnParameter* ForestParameter::add_leaf_node_fcn_param() {
  // @@protoc_insertion_point(field_add:rv.rf.ForestParameter.leaf_node_fcn_param)
  return leaf_node_fcn_param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rv::rf::LeafNodeFcnParameter >&
ForestParameter::leaf_node_fcn_param() const {
  // @@protoc_insertion_point(field_list:rv.rf.ForestParameter.leaf_node_fcn_param)
  return leaf_node_fcn_param_;
}
inline ::google::protobuf::RepeatedPtrField< ::rv::rf::LeafNodeFcnParameter >*
ForestParameter::mutable_leaf_node_fcn_param() {
  // @@protoc_insertion_point(field_mutable_list:rv.rf.ForestParameter.leaf_node_fcn_param)
  return &leaf_node_fcn_param_;
}

// optional uint32 n_trees = 5 [default = 4];
inline bool ForestParameter::has_n_trees() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ForestParameter::set_has_n_trees() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ForestParameter::clear_has_n_trees() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ForestParameter::clear_n_trees() {
  n_trees_ = 4u;
  clear_has_n_trees();
}
inline ::google::protobuf::uint32 ForestParameter::n_trees() const {
  // @@protoc_insertion_point(field_get:rv.rf.ForestParameter.n_trees)
  return n_trees_;
}
inline void ForestParameter::set_n_trees(::google::protobuf::uint32 value) {
  set_has_n_trees();
  n_trees_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.ForestParameter.n_trees)
}

// optional uint32 max_tree_depth = 6 [default = 5];
inline bool ForestParameter::has_max_tree_depth() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ForestParameter::set_has_max_tree_depth() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ForestParameter::clear_has_max_tree_depth() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ForestParameter::clear_max_tree_depth() {
  max_tree_depth_ = 5u;
  clear_has_max_tree_depth();
}
inline ::google::protobuf::uint32 ForestParameter::max_tree_depth() const {
  // @@protoc_insertion_point(field_get:rv.rf.ForestParameter.max_tree_depth)
  return max_tree_depth_;
}
inline void ForestParameter::set_max_tree_depth(::google::protobuf::uint32 value) {
  set_has_max_tree_depth();
  max_tree_depth_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.ForestParameter.max_tree_depth)
}

// optional uint32 n_test_samples = 7 [default = 1000];
inline bool ForestParameter::has_n_test_samples() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ForestParameter::set_has_n_test_samples() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ForestParameter::clear_has_n_test_samples() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ForestParameter::clear_n_test_samples() {
  n_test_samples_ = 1000u;
  clear_has_n_test_samples();
}
inline ::google::protobuf::uint32 ForestParameter::n_test_samples() const {
  // @@protoc_insertion_point(field_get:rv.rf.ForestParameter.n_test_samples)
  return n_test_samples_;
}
inline void ForestParameter::set_n_test_samples(::google::protobuf::uint32 value) {
  set_has_n_test_samples();
  n_test_samples_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.ForestParameter.n_test_samples)
}

// optional uint32 n_test_split_functions = 8 [default = 100];
inline bool ForestParameter::has_n_test_split_functions() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ForestParameter::set_has_n_test_split_functions() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ForestParameter::clear_has_n_test_split_functions() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ForestParameter::clear_n_test_split_functions() {
  n_test_split_functions_ = 100u;
  clear_has_n_test_split_functions();
}
inline ::google::protobuf::uint32 ForestParameter::n_test_split_functions() const {
  // @@protoc_insertion_point(field_get:rv.rf.ForestParameter.n_test_split_functions)
  return n_test_split_functions_;
}
inline void ForestParameter::set_n_test_split_functions(::google::protobuf::uint32 value) {
  set_has_n_test_split_functions();
  n_test_split_functions_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.ForestParameter.n_test_split_functions)
}

// optional uint32 n_test_thresholds = 9 [default = 10];
inline bool ForestParameter::has_n_test_thresholds() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ForestParameter::set_has_n_test_thresholds() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ForestParameter::clear_has_n_test_thresholds() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ForestParameter::clear_n_test_thresholds() {
  n_test_thresholds_ = 10u;
  clear_has_n_test_thresholds();
}
inline ::google::protobuf::uint32 ForestParameter::n_test_thresholds() const {
  // @@protoc_insertion_point(field_get:rv.rf.ForestParameter.n_test_thresholds)
  return n_test_thresholds_;
}
inline void ForestParameter::set_n_test_thresholds(::google::protobuf::uint32 value) {
  set_has_n_test_thresholds();
  n_test_thresholds_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.ForestParameter.n_test_thresholds)
}

// optional uint32 min_samples_to_split = 10 [default = 5];
inline bool ForestParameter::has_min_samples_to_split() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ForestParameter::set_has_min_samples_to_split() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ForestParameter::clear_has_min_samples_to_split() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ForestParameter::clear_min_samples_to_split() {
  min_samples_to_split_ = 5u;
  clear_has_min_samples_to_split();
}
inline ::google::protobuf::uint32 ForestParameter::min_samples_to_split() const {
  // @@protoc_insertion_point(field_get:rv.rf.ForestParameter.min_samples_to_split)
  return min_samples_to_split_;
}
inline void ForestParameter::set_min_samples_to_split(::google::protobuf::uint32 value) {
  set_has_min_samples_to_split();
  min_samples_to_split_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.ForestParameter.min_samples_to_split)
}

// optional uint32 min_samples_for_leaf = 11 [default = 1];
inline bool ForestParameter::has_min_samples_for_leaf() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ForestParameter::set_has_min_samples_for_leaf() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ForestParameter::clear_has_min_samples_for_leaf() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ForestParameter::clear_min_samples_for_leaf() {
  min_samples_for_leaf_ = 1u;
  clear_has_min_samples_for_leaf();
}
inline ::google::protobuf::uint32 ForestParameter::min_samples_for_leaf() const {
  // @@protoc_insertion_point(field_get:rv.rf.ForestParameter.min_samples_for_leaf)
  return min_samples_for_leaf_;
}
inline void ForestParameter::set_min_samples_for_leaf(::google::protobuf::uint32 value) {
  set_has_min_samples_for_leaf();
  min_samples_for_leaf_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.ForestParameter.min_samples_for_leaf)
}

// -------------------------------------------------------------------

// SplitFunctionParameter

// optional .rv.rf.SplitFunctionParameter.SplitFunctionType type = 1 [default = PIXEL_VALUE];
inline bool SplitFunctionParameter::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SplitFunctionParameter::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SplitFunctionParameter::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SplitFunctionParameter::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::rv::rf::SplitFunctionParameter_SplitFunctionType SplitFunctionParameter::type() const {
  // @@protoc_insertion_point(field_get:rv.rf.SplitFunctionParameter.type)
  return static_cast< ::rv::rf::SplitFunctionParameter_SplitFunctionType >(type_);
}
inline void SplitFunctionParameter::set_type(::rv::rf::SplitFunctionParameter_SplitFunctionType value) {
  assert(::rv::rf::SplitFunctionParameter_SplitFunctionType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.SplitFunctionParameter.type)
}

// optional uint32 gen_n_slices = 2 [default = 1];
inline bool SplitFunctionParameter::has_gen_n_slices() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SplitFunctionParameter::set_has_gen_n_slices() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SplitFunctionParameter::clear_has_gen_n_slices() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SplitFunctionParameter::clear_gen_n_slices() {
  gen_n_slices_ = 1u;
  clear_has_gen_n_slices();
}
inline ::google::protobuf::uint32 SplitFunctionParameter::gen_n_slices() const {
  // @@protoc_insertion_point(field_get:rv.rf.SplitFunctionParameter.gen_n_slices)
  return gen_n_slices_;
}
inline void SplitFunctionParameter::set_gen_n_slices(::google::protobuf::uint32 value) {
  set_has_gen_n_slices();
  gen_n_slices_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.SplitFunctionParameter.gen_n_slices)
}

// optional bool gen_fix_one = 3 [default = false];
inline bool SplitFunctionParameter::has_gen_fix_one() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SplitFunctionParameter::set_has_gen_fix_one() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SplitFunctionParameter::clear_has_gen_fix_one() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SplitFunctionParameter::clear_gen_fix_one() {
  gen_fix_one_ = false;
  clear_has_gen_fix_one();
}
inline bool SplitFunctionParameter::gen_fix_one() const {
  // @@protoc_insertion_point(field_get:rv.rf.SplitFunctionParameter.gen_fix_one)
  return gen_fix_one_;
}
inline void SplitFunctionParameter::set_gen_fix_one(bool value) {
  set_has_gen_fix_one();
  gen_fix_one_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.SplitFunctionParameter.gen_fix_one)
}

// optional .rv.rf.SplitFunctionParameter.GeneratorSpace gen_space = 4 [default = DATA_LINEAR];
inline bool SplitFunctionParameter::has_gen_space() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SplitFunctionParameter::set_has_gen_space() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SplitFunctionParameter::clear_has_gen_space() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SplitFunctionParameter::clear_gen_space() {
  gen_space_ = 2;
  clear_has_gen_space();
}
inline ::rv::rf::SplitFunctionParameter_GeneratorSpace SplitFunctionParameter::gen_space() const {
  // @@protoc_insertion_point(field_get:rv.rf.SplitFunctionParameter.gen_space)
  return static_cast< ::rv::rf::SplitFunctionParameter_GeneratorSpace >(gen_space_);
}
inline void SplitFunctionParameter::set_gen_space(::rv::rf::SplitFunctionParameter_GeneratorSpace value) {
  assert(::rv::rf::SplitFunctionParameter_GeneratorSpace_IsValid(value));
  set_has_gen_space();
  gen_space_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.SplitFunctionParameter.gen_space)
}

// optional float gen_x_from = 5;
inline bool SplitFunctionParameter::has_gen_x_from() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SplitFunctionParameter::set_has_gen_x_from() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SplitFunctionParameter::clear_has_gen_x_from() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SplitFunctionParameter::clear_gen_x_from() {
  gen_x_from_ = 0;
  clear_has_gen_x_from();
}
inline float SplitFunctionParameter::gen_x_from() const {
  // @@protoc_insertion_point(field_get:rv.rf.SplitFunctionParameter.gen_x_from)
  return gen_x_from_;
}
inline void SplitFunctionParameter::set_gen_x_from(float value) {
  set_has_gen_x_from();
  gen_x_from_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.SplitFunctionParameter.gen_x_from)
}

// optional float gen_x_to = 6;
inline bool SplitFunctionParameter::has_gen_x_to() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SplitFunctionParameter::set_has_gen_x_to() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SplitFunctionParameter::clear_has_gen_x_to() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SplitFunctionParameter::clear_gen_x_to() {
  gen_x_to_ = 0;
  clear_has_gen_x_to();
}
inline float SplitFunctionParameter::gen_x_to() const {
  // @@protoc_insertion_point(field_get:rv.rf.SplitFunctionParameter.gen_x_to)
  return gen_x_to_;
}
inline void SplitFunctionParameter::set_gen_x_to(float value) {
  set_has_gen_x_to();
  gen_x_to_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.SplitFunctionParameter.gen_x_to)
}

// optional uint32 gen_x_n = 7;
inline bool SplitFunctionParameter::has_gen_x_n() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SplitFunctionParameter::set_has_gen_x_n() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SplitFunctionParameter::clear_has_gen_x_n() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SplitFunctionParameter::clear_gen_x_n() {
  gen_x_n_ = 0u;
  clear_has_gen_x_n();
}
inline ::google::protobuf::uint32 SplitFunctionParameter::gen_x_n() const {
  // @@protoc_insertion_point(field_get:rv.rf.SplitFunctionParameter.gen_x_n)
  return gen_x_n_;
}
inline void SplitFunctionParameter::set_gen_x_n(::google::protobuf::uint32 value) {
  set_has_gen_x_n();
  gen_x_n_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.SplitFunctionParameter.gen_x_n)
}

// optional float gen_y_from = 8;
inline bool SplitFunctionParameter::has_gen_y_from() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SplitFunctionParameter::set_has_gen_y_from() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SplitFunctionParameter::clear_has_gen_y_from() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SplitFunctionParameter::clear_gen_y_from() {
  gen_y_from_ = 0;
  clear_has_gen_y_from();
}
inline float SplitFunctionParameter::gen_y_from() const {
  // @@protoc_insertion_point(field_get:rv.rf.SplitFunctionParameter.gen_y_from)
  return gen_y_from_;
}
inline void SplitFunctionParameter::set_gen_y_from(float value) {
  set_has_gen_y_from();
  gen_y_from_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.SplitFunctionParameter.gen_y_from)
}

// optional float gen_y_to = 9;
inline bool SplitFunctionParameter::has_gen_y_to() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SplitFunctionParameter::set_has_gen_y_to() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SplitFunctionParameter::clear_has_gen_y_to() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SplitFunctionParameter::clear_gen_y_to() {
  gen_y_to_ = 0;
  clear_has_gen_y_to();
}
inline float SplitFunctionParameter::gen_y_to() const {
  // @@protoc_insertion_point(field_get:rv.rf.SplitFunctionParameter.gen_y_to)
  return gen_y_to_;
}
inline void SplitFunctionParameter::set_gen_y_to(float value) {
  set_has_gen_y_to();
  gen_y_to_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.SplitFunctionParameter.gen_y_to)
}

// optional uint32 gen_y_n = 10;
inline bool SplitFunctionParameter::has_gen_y_n() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SplitFunctionParameter::set_has_gen_y_n() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SplitFunctionParameter::clear_has_gen_y_n() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SplitFunctionParameter::clear_gen_y_n() {
  gen_y_n_ = 0u;
  clear_has_gen_y_n();
}
inline ::google::protobuf::uint32 SplitFunctionParameter::gen_y_n() const {
  // @@protoc_insertion_point(field_get:rv.rf.SplitFunctionParameter.gen_y_n)
  return gen_y_n_;
}
inline void SplitFunctionParameter::set_gen_y_n(::google::protobuf::uint32 value) {
  set_has_gen_y_n();
  gen_y_n_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.SplitFunctionParameter.gen_y_n)
}

// optional string basis_csv = 11 [default = ""];
inline bool SplitFunctionParameter::has_basis_csv() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SplitFunctionParameter::set_has_basis_csv() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SplitFunctionParameter::clear_has_basis_csv() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SplitFunctionParameter::clear_basis_csv() {
  if (basis_csv_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basis_csv_->clear();
  }
  clear_has_basis_csv();
}
inline const ::std::string& SplitFunctionParameter::basis_csv() const {
  // @@protoc_insertion_point(field_get:rv.rf.SplitFunctionParameter.basis_csv)
  return *basis_csv_;
}
inline void SplitFunctionParameter::set_basis_csv(const ::std::string& value) {
  set_has_basis_csv();
  if (basis_csv_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basis_csv_ = new ::std::string;
  }
  basis_csv_->assign(value);
  // @@protoc_insertion_point(field_set:rv.rf.SplitFunctionParameter.basis_csv)
}
inline void SplitFunctionParameter::set_basis_csv(const char* value) {
  set_has_basis_csv();
  if (basis_csv_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basis_csv_ = new ::std::string;
  }
  basis_csv_->assign(value);
  // @@protoc_insertion_point(field_set_char:rv.rf.SplitFunctionParameter.basis_csv)
}
inline void SplitFunctionParameter::set_basis_csv(const char* value, size_t size) {
  set_has_basis_csv();
  if (basis_csv_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basis_csv_ = new ::std::string;
  }
  basis_csv_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:rv.rf.SplitFunctionParameter.basis_csv)
}
inline ::std::string* SplitFunctionParameter::mutable_basis_csv() {
  set_has_basis_csv();
  if (basis_csv_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    basis_csv_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:rv.rf.SplitFunctionParameter.basis_csv)
  return basis_csv_;
}
inline ::std::string* SplitFunctionParameter::release_basis_csv() {
  clear_has_basis_csv();
  if (basis_csv_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = basis_csv_;
    basis_csv_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SplitFunctionParameter::set_allocated_basis_csv(::std::string* basis_csv) {
  if (basis_csv_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete basis_csv_;
  }
  if (basis_csv) {
    set_has_basis_csv();
    basis_csv_ = basis_csv;
  } else {
    clear_has_basis_csv();
    basis_csv_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:rv.rf.SplitFunctionParameter.basis_csv)
}

// -------------------------------------------------------------------

// SplitEvaluatorParameter

// optional .rv.rf.SplitEvaluatorParameter.SplitEvaluatorType type = 1 [default = CLASSIFICATION_INFORMATION_GAIN];
inline bool SplitEvaluatorParameter::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SplitEvaluatorParameter::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SplitEvaluatorParameter::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SplitEvaluatorParameter::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::rv::rf::SplitEvaluatorParameter_SplitEvaluatorType SplitEvaluatorParameter::type() const {
  // @@protoc_insertion_point(field_get:rv.rf.SplitEvaluatorParameter.type)
  return static_cast< ::rv::rf::SplitEvaluatorParameter_SplitEvaluatorType >(type_);
}
inline void SplitEvaluatorParameter::set_type(::rv::rf::SplitEvaluatorParameter_SplitEvaluatorType value) {
  assert(::rv::rf::SplitEvaluatorParameter_SplitEvaluatorType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.SplitEvaluatorParameter.type)
}

// optional bool normalize = 2 [default = true];
inline bool SplitEvaluatorParameter::has_normalize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SplitEvaluatorParameter::set_has_normalize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SplitEvaluatorParameter::clear_has_normalize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SplitEvaluatorParameter::clear_normalize() {
  normalize_ = true;
  clear_has_normalize();
}
inline bool SplitEvaluatorParameter::normalize() const {
  // @@protoc_insertion_point(field_get:rv.rf.SplitEvaluatorParameter.normalize)
  return normalize_;
}
inline void SplitEvaluatorParameter::set_normalize(bool value) {
  set_has_normalize();
  normalize_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.SplitEvaluatorParameter.normalize)
}

// optional float weight = 3 [default = 1];
inline bool SplitEvaluatorParameter::has_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SplitEvaluatorParameter::set_has_weight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SplitEvaluatorParameter::clear_has_weight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SplitEvaluatorParameter::clear_weight() {
  weight_ = 1;
  clear_has_weight();
}
inline float SplitEvaluatorParameter::weight() const {
  // @@protoc_insertion_point(field_get:rv.rf.SplitEvaluatorParameter.weight)
  return weight_;
}
inline void SplitEvaluatorParameter::set_weight(float value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.SplitEvaluatorParameter.weight)
}

// optional bool weighted_mean = 4 [default = false];
inline bool SplitEvaluatorParameter::has_weighted_mean() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SplitEvaluatorParameter::set_has_weighted_mean() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SplitEvaluatorParameter::clear_has_weighted_mean() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SplitEvaluatorParameter::clear_weighted_mean() {
  weighted_mean_ = false;
  clear_has_weighted_mean();
}
inline bool SplitEvaluatorParameter::weighted_mean() const {
  // @@protoc_insertion_point(field_get:rv.rf.SplitEvaluatorParameter.weighted_mean)
  return weighted_mean_;
}
inline void SplitEvaluatorParameter::set_weighted_mean(bool value) {
  set_has_weighted_mean();
  weighted_mean_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.SplitEvaluatorParameter.weighted_mean)
}

// -------------------------------------------------------------------

// LeafNodeFcnParameter

// optional .rv.rf.LeafNodeFcnParameter.LeafNodeFcnType type = 1 [default = CLASSIFICATION];
inline bool LeafNodeFcnParameter::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeafNodeFcnParameter::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeafNodeFcnParameter::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeafNodeFcnParameter::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::rv::rf::LeafNodeFcnParameter_LeafNodeFcnType LeafNodeFcnParameter::type() const {
  // @@protoc_insertion_point(field_get:rv.rf.LeafNodeFcnParameter.type)
  return static_cast< ::rv::rf::LeafNodeFcnParameter_LeafNodeFcnType >(type_);
}
inline void LeafNodeFcnParameter::set_type(::rv::rf::LeafNodeFcnParameter_LeafNodeFcnType value) {
  assert(::rv::rf::LeafNodeFcnParameter_LeafNodeFcnType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.LeafNodeFcnParameter.type)
}

// optional float lambda = 2 [default = 0];
inline bool LeafNodeFcnParameter::has_lambda() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeafNodeFcnParameter::set_has_lambda() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LeafNodeFcnParameter::clear_has_lambda() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LeafNodeFcnParameter::clear_lambda() {
  lambda_ = 0;
  clear_has_lambda();
}
inline float LeafNodeFcnParameter::lambda() const {
  // @@protoc_insertion_point(field_get:rv.rf.LeafNodeFcnParameter.lambda)
  return lambda_;
}
inline void LeafNodeFcnParameter::set_lambda(float value) {
  set_has_lambda();
  lambda_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.LeafNodeFcnParameter.lambda)
}

// optional bool use_bias = 3 [default = true];
inline bool LeafNodeFcnParameter::has_use_bias() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LeafNodeFcnParameter::set_has_use_bias() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LeafNodeFcnParameter::clear_has_use_bias() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LeafNodeFcnParameter::clear_use_bias() {
  use_bias_ = true;
  clear_has_use_bias();
}
inline bool LeafNodeFcnParameter::use_bias() const {
  // @@protoc_insertion_point(field_get:rv.rf.LeafNodeFcnParameter.use_bias)
  return use_bias_;
}
inline void LeafNodeFcnParameter::set_use_bias(bool value) {
  set_has_use_bias();
  use_bias_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.LeafNodeFcnParameter.use_bias)
}

// optional uint32 poly_degree = 4 [default = 1];
inline bool LeafNodeFcnParameter::has_poly_degree() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LeafNodeFcnParameter::set_has_poly_degree() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LeafNodeFcnParameter::clear_has_poly_degree() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LeafNodeFcnParameter::clear_poly_degree() {
  poly_degree_ = 1u;
  clear_has_poly_degree();
}
inline ::google::protobuf::uint32 LeafNodeFcnParameter::poly_degree() const {
  // @@protoc_insertion_point(field_get:rv.rf.LeafNodeFcnParameter.poly_degree)
  return poly_degree_;
}
inline void LeafNodeFcnParameter::set_poly_degree(::google::protobuf::uint32 value) {
  set_has_poly_degree();
  poly_degree_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.LeafNodeFcnParameter.poly_degree)
}

// optional bool weighted_regression = 5 [default = false];
inline bool LeafNodeFcnParameter::has_weighted_regression() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LeafNodeFcnParameter::set_has_weighted_regression() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LeafNodeFcnParameter::clear_has_weighted_regression() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LeafNodeFcnParameter::clear_weighted_regression() {
  weighted_regression_ = false;
  clear_has_weighted_regression();
}
inline bool LeafNodeFcnParameter::weighted_regression() const {
  // @@protoc_insertion_point(field_get:rv.rf.LeafNodeFcnParameter.weighted_regression)
  return weighted_regression_;
}
inline void LeafNodeFcnParameter::set_weighted_regression(bool value) {
  set_has_weighted_regression();
  weighted_regression_ = value;
  // @@protoc_insertion_point(field_set:rv.rf.LeafNodeFcnParameter.weighted_regression)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace rf
}  // namespace rv

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::rv::rf::ForestParameter_NodeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rv::rf::ForestParameter_NodeType>() {
  return ::rv::rf::ForestParameter_NodeType_descriptor();
}
template <> struct is_proto_enum< ::rv::rf::SplitFunctionParameter_SplitFunctionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rv::rf::SplitFunctionParameter_SplitFunctionType>() {
  return ::rv::rf::SplitFunctionParameter_SplitFunctionType_descriptor();
}
template <> struct is_proto_enum< ::rv::rf::SplitFunctionParameter_GeneratorSpace> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rv::rf::SplitFunctionParameter_GeneratorSpace>() {
  return ::rv::rf::SplitFunctionParameter_GeneratorSpace_descriptor();
}
template <> struct is_proto_enum< ::rv::rf::SplitEvaluatorParameter_SplitEvaluatorType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rv::rf::SplitEvaluatorParameter_SplitEvaluatorType>() {
  return ::rv::rf::SplitEvaluatorParameter_SplitEvaluatorType_descriptor();
}
template <> struct is_proto_enum< ::rv::rf::LeafNodeFcnParameter_LeafNodeFcnType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rv::rf::LeafNodeFcnParameter_LeafNodeFcnType>() {
  return ::rv::rf::LeafNodeFcnParameter_LeafNodeFcnType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rf_2eproto__INCLUDED
